[{"title":"","date":"2017-07-30T12:44:10.421Z","path":"2017/07/30/react+antd+dva项目中list模块的开发流程及实现/","text":"react+antd+dva项目中List模块的开发流程及实现 相关链接： React官网 antd官网 dva_github地址 antd：蚂蚁金服开源的一个开源的组件库dva：基于 redux、redux-saga 和 react-router@2.x 的轻量级前端框架。 该项目是基于antd-admin (Demo), antd 和 dva 的后台管理应用详情可见 antd-admin__github地址 技术储备 React redux （在这个功能的实现上这个不是必须的，它用来对组件状态与数据进行管理比较方便，类似的还有Flux，而在这个项目中，dva是以他们为基础的） dva （脚手架，快速搭建项目，并且有自己的规范，是一个框架） dva 官方给出了很详细的介绍 理解dva的8个概念，以及他们是如何串联起来的 掌握dva的所有API dva知识地图，包含ES6、React、dva等所有基础知识 List的功能需求 主要就是在***项目中的**模块,要有一个创建和展示的需求（本文是将展示的实现） 展示模块，有一个查询的功能 List中要有编辑和删除功能及删除选中项 具体流程 项目的大致结构图： 1. 创建基础文件 项目资源文件全部保存在src文件夹下，找到routes文件，创建一个新的文件夹，一般使我们该模块的名字–housekeeping，并在改文件夹下创建一个index.js（加载组件是方便，不用写扩展名直接加载文件夹名即可，自动查找index文件） 找到models文件夹，并创建一个对应的model文件，housekeeping.js，用来管理模块的数据及状态 service文件夹下创建一个属于该模块的服务（暴露一些异步请求数据的方法） 2. 关于该项目的一些配置 一些固定的配置、参数及方法都在untils文件夹下，针对我们的开发只需要东两个文件，config.js与menu.js。menu.js是在slider模块中添加我们模块的nav，在config.js中主要是配置给模块的请求数据API地址。 3. 增加route.js配置 增加route.js的配置，就是为了监听路由，当路由是我们这个模块的时候，要去加载相应的组件 4. 编写index.js文件 处于组件化和后期好管理的目的，List模块中分离出来两个小的组件。我理解是纯组件 查询搜索功能组件Filter.js 展示Table组件List.js 5. Filter.js 既然用的是antd，所以我们可以很方便的写好Filter组件，我用的是antd的Form这一块，具体使用方法和api可以参考antd官网，说明很详细主要我们要拿到form表单的数据，发送请求，拿数据并渲染。具体它是怎么工作的，怎么去重新渲染table，list之后再说会比较好一点 6. List.js List更为简单一些，主要就是antd里面的Table组件的应用 7. list的数据来源 在model文件夹中我们创建的housekeeping.js中进行在model中的subscription可以订阅一个信息，通过setup来监听路由，当进入到List模块时，我们就去加载list的数据，供我们的模块来使用，组件与模块的连接通过connect来完成，如果我们的是用过函数的方式来创建的组件，可以通过的参数传过来，穿过来的是该模块model的state对象。所以我们subscription订阅的信息要经过model中reducer处理数据然后放到state中，比如在state对象中的options属性中。然后我们组件index.js就能通过传参的形式拿到这个数据，然后通过props的形式传给我们封装的List组件，如果格式符合table的options属性的格式，可以直接给Table。 8. 查询功能的实现主要是拿到用户输入的数据，发送请求，拿到匹配的数据，通过dispatch方法，改变state中options的数据即可。state发生改变，页面就会重新被渲染。 关于如何创建和编辑删除等功能……","tags":[]},{"title":"","date":"2017-05-06T01:14:25.048Z","path":"2017/05/06/ajax/","text":"Ajax相关概念前端相关的技术点： html（html5） 主要用来实现页面的排版布局 css（css3） 主要用来实现页面的样式美化 JavaScript（jQuery） 主要用来实现前端功能特效 采用上面的这些技术开发的页面和前端特效脚本需要放到服务器才能够对外提供服务，才能够让互联网上的网友看到。 客户端与服务器 本质上都是计算机，只不过样子不同，配置不同，应用场景不同（安装的应用软件不同） 客户端主要用于普通上网用户 服务器主要给上网用户提供后台服务 网络相关概念 IP地址（唯一的确定互联网上的一台计算机） 域名 IP地址的别名，方便记忆 DNS 用于维护IP地址与域名的关系 端口 用来确定计算机上的网络应用程序 通信协议理解 通信双方约定的规则 http/https 超为本传输协议 ftp 文件传输协议 smpt/pop3 邮件收发协议 …… 搭建服务器环境wamp集成环境介绍 windows 操作系统 Apache 提供静态资源服务（html页面、js文件、css文件、图片。。。） MySQL 数据库 php 编程语言，可以用来开发网站wamp的安装配置 参见详细文档 网站 网站由一系列页面组成（页面由js、css、图片、html标签。。。所有的这些文件都被称为资源） 静态网站就是提前写好的html页面（包括图片、媒体文件。。。静态资源文件），并且部署到服务器上静态网站主要存在的问题： 随着网站规模的增大可维护性逐渐降低 没有交互性 动态网站 动态指的是html页面是动态生成的，这里动态生成的不一定是一个完整的页面，有可能仅仅是页面的一部分，或者仅仅是数据(普通字符串、json、xml)实现动态网站的技术： php java（jsp） .net Node.js python …… PHP基础 php是一种后台编程语言；使用php可以开发动态网站和后台接口（所谓接口就是url地址，用于给前端提供数据）。 php基础语法 变量 字符串拼接 单引号与双引号 内容输出 数据类型 运算符 分支循环语句 函数 预定义变量（表单处理）变量变量以$开头 字母/数字/下划线 不能以数字开头，大小写敏感。内容输出 echo：输出简单数据类型，如字符串、数值 print_r()：输出复杂数据类型，如数组 var_dump()：输出详细信息，如对象、数组字符串拼接 js中字符串拼接用+；php中字符串拼接用.单引号与双引号 单引号中的变量会当作普通字符串处理 双引号中的变量会解析为变量值运算符 与JavaScript基本类似数据类型 字符串 整型 浮点型 布尔型 数组 对象 NULL预定义变量（表单处理） $_GET $_POST分支循环 if/switch while for foreach函数自定义函数 语法规则（函数名不区分大小写）系统函数 gettype() json_encode() Part 1第一节 AJAX并不是一门新技术，而是多种技术的结合体- 1、一些有趣的事 1. AJAX 不是新的编程语言，而是一种使用已有标准的新概念 2. 2005年由美国人Jesse James Garrett推广，并取名。 神奇的是，这哥们并不是搞程序的，而是搞设计的，是交互设计大师、用户体验大师。甚至是个优秀建筑设计师。 3. 在 2005 年，Google 通过其 Google Suggest 使 AJAX 变得流行起来。 4. 在今天，很少有哪个网站不使用Ajax技术 5. Ajax技术对智能手机支持非常好。 6. Ajax中字母x表示XML，实际上XML已经过时，现在的公司，几乎全都在使用JSON代替XML。 所以理论上讲，应该称呼为Ajaj，不过，呃，这个词儿，长得好难看。 - 2、AJAX 是一个什么东西 在不刷新页面的情况下， 浏览器悄悄地、异步地向服务器发出HTTP请求。 服务器收到请求后，传回新的格式化数据回来（通常是JSON）。 浏览器解析JSON，通过DOM将新数据呈递显示，页面仅局部刷新。 第二节 服务器与客户端1. 服务器和客户端说白了，都是电脑 2. 服务器：能够提供某种服务的机器（计算机） 3. 客户端：具有向服务器索取服务能力的终端 4. 服务器类型： a、按服务类型可分为：文件服务器、数据库服务器、邮件服务器、Web 服务器等； b、按操作系统可分为：Linux服务器、Windows服务器等 c、按应用软件可分为 Apache服务器、Nginx 服务器、IIS服务器、Tomcat服务器、Node服务器等 5. 服务器软件 定义：使计算机具备提供某种服务能力的应用软件，称为服务器软件， 通过安装相应的服务软件，然后进行配置后就可以使计算具备了提供某种服务的能力。 常见的服务器软件： a、文件服务器：Server-U、FileZilla、VsFTP等 b、数据库服务器：Oracle、MySQL、PostgreSQL、MSSQL c、邮件服务器：Postfix、Sendmail d、HTTP 服务器：Apache、Nginx、IIS、Tomcat、NodeJS 第三节 基础知识铺垫-网络相关概念- 1. 什么是IP地址，如何查看IP 所谓IP地址就是给每个连接在互联网上的主机分配的一个32位地址。 查看本机的IP： ipconfig 或者ipconfig -all 查看域名的IP： ping - 2. 域名 由于IP地址是基于数字，不方便记忆，于是便用域名来代替IP地址， 说百了，域名就是方便IP的的别名，替代品 - 3. DNS以及查找的规则 记录了 IP 地址和域名的映射（对应）关系。 查找优先级 本机hosts文件、DNS服务器 - 4. 端口 端口是计算机与外界通讯交流的出口，每个端口对应不同的服务。 说白了就是服务所对应的出口。 - 5. 一个域名可以对应多个IP 但是一个IP只能对应一个域名 第四节 通信协议1. 常见的通信协议 a、HTTP、HTTPS 超文本传输协议 ---- 默认http是80端口,https是443端口 b、FTP 文件传输协议 ---- 默认是 21 端口 c、SMTP 简单邮件传输协议 ---- 默认是 25 端口 2. HTTP协议 即超文本传输协议，网站是基于HTTP协议的。 HTTP协议是由从客户机到服务器的请求(Request)和从服务器到客户机的响应(Response)进行了约束和规范。 即HTTP协议主要由请求和响应构成。 3. HTTPS协议 以安全为目标的HTTP通道，简单讲是HTTP的安全版。 即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 SSL即安全套接层，是为网络通信提供安全及数据完整性的一种安全协议。 详细了解：百度百科（https://baike.baidu.com/） 4. C/S 和 B/S --- 网络结构模式 C/S --- 客户机和服务器模式 --- 例如QQ、迅雷 B/S --- 浏览器和服务器模式 --- 例如OA、网页版QQ、网页版263邮箱 但要注意： B/S是基于特定通信协议(HTTP)的C/S架构，也就是说B/S包含在C/S中，是特殊的C/S架构。 B/S属于C/S，浏览器只是特殊的客户端，本质上开发浏览器，还是实现一个C/S系统。 详细了解：百度百科（https://baike.baidu.com/） 第五节 服务器环境wamp安装如果wamp没有安装成功的，按照如下方式安装PHPStudy 第六节 配置访问权限与网站根路径配置访问权限 1. 安装位置 -- C:\\wamp\\bin\\apache\\Apache2.4.4\\conf\\httpd.conf 2. 搜索Deny（268行） ，将 Deny 改成 Allow 配置网站根路径 1. 240行和241行，改成自己根目录的位置 第七节 基础知识铺垫-虚拟主机配置1. 安装位置 -- C:\\wamp\\bin\\apache\\Apache2.4.4\\conf\\httpd.conf 2. 搜索hosts（499行），去掉下一行(500行)的 “ # ” 3. C:\\wamp\\bin\\apache\\Apache2.4.4\\conf\\extra\\httpd-vhosts.conf 4. 配置网站根目录 5. 更改hosts，映射到本地 第八节 静态网站1. 全部由HTML（标准通用标记语言的子集）代码格式页面组成的网站，所有的内容包含在网页文件中。 一般文件名均以htm、html、shtml等为后缀。 2. 优点： a、静态网页的内容相对稳定，因此容易被搜索引擎检索 3. 缺点： a、没有数据库的支持，在网站制作和维护方面工作量较大 b、静态网页的交互性较差，在功能方面有较大的限制 。 第九节 动态网站1. 动态网站并不是指具有动画功能的网站，而是指网站内容可根据不同情况动态变更的网站， 一般情况下动态网站通过数据库进行架构。 一般动态网站体现在网页一般是以asp，jsp，php，aspx等结尾。 2. 优点： a、动态网页以数据库技术为基础，可以大大降低网站维护的工作量。 b、交互能力强，网页会根据用户的要求和选择而动态改变和响应。 c、维护方便，即无需手动操作，便会自动生成新的页面 3. 缺点 a、动态网页中的“？”对搜索引擎检索存在一定的问题， 因此采用动态网页的网站在进行搜索引擎推广时需要做一定的技术处理才能适应搜索引擎的要求 第十节 php基础语法 —- 初识php1. 所有的PHP相关的代码都要写在&lt;?php … ?&gt;里面。 echo 的作用就是像页面当中输入字符串 2. PHP 文件的默认文件扩展名是 &quot;.php&quot;。 3. PHP脚本在服务器上执行。AJAX也是， 所有咱们现在写代码都要放在Apache服务器下打开 4. PHP 语句以分号结尾（;）。 第十一节 php基础语法 —- 变量声明与字符串拼接1. PHP中定义变量使用的 $ 操作符； 2. PHP中的的字符拼接使用的“ . ”； 3. PHP中的单引号把包含在其中的变量当做普通的字符串来处理 PHP中的双印号把包含在其中的变量当做变量解析成变量值 4. 所有用户定义的函数、类和关键词（例如 if、else、echo 等等）都对大小写不敏感 【但是PHP所有变量对大小写敏感】 5. PHP的变量声明以及变量名的规则 a、变量以 $ 符号开头，其后是变量的名称 b、变量名称必须以字母或下划线开头 c、变量名称不能以数字开头 d、变量名称只能包含字母数字字符和下划线（A-z、0-9 以及 _） e、变量名称对大小写敏感（$y 与 $Y 是两个不同的变量） 第十二节 php基础语法 —- 初始数组1. echo --- 输出简单数据类型，如字符串、数值 2. print_r() --- 输出复杂数据类型，如数组 3. var_dump() --- 输出详细信息，如对象、数组 第十三节 php基础语法 —- 二维数组访问二位数组 第十四节 php基础语法 —- 数据类型与数组遍历1. php的数据类型与JavaScript的数据类型是类似的，都是弱类型语言 2. gettype() 内置函数，用来判断变量的类型 3. count()是内置函数，用来计算数组的长度 Part 2第一节 php基础语法 —- 函数1. 自定义函数，语法类似与JavaScript 2. 系统函数直接调用，不需要声明 3. json_encode() --- 将数组和对象转换为字符串的方法; 第二节 php基础语法 —- get请求参数获取1. http协议的常用请求方式：（增删改查） a、get 用来从服务器获取数据（参数一般作为查询条件） b、post 用来添加数据 c、put 用来修改数据 d、delete 用来删除数据 2. $_GET[&apos;abc&apos;]得到url地址中传递的参数的值 3. $_GET是PHP内置好的专门用来接数据用的一个全局数组 4. 注意：绝不能使用 GET 来发送密码或其他敏感信息 第三节 php基础语法 —- post请求参数获取1. form 默认请求方式就是get请求，get请求会把表单数据作为url的参数进行提交 2. 设置服务响应的文件类型： 1. header(&quot;Content-Type: text/plain; charset=utf-8&quot;); 2. header(&quot;Content-Type: text/html; charset=utf-8&quot;); 3. $_POST也是PHP内置好的专门用来接数据用的一个全局数组 GET和POST请求方式的差异 1. GET没有请求主体，使用xhr.send(null) 2. GET可以通过在请求URL上添加请求参数 3. POST有请求主体，可以通过xhr.send(&apos;name=itcast&amp;age=10&apos;) 4. POST需要设置请求头 5. GET效率更好（应用多） 6. GET大小限制约4K，POST则没有限制 7.get 方式提交不太安全，post方式相对来说比较安全 第四节 案例第五节 php基础语法-10-后台接口1. 将数组和对象转换为字符串的方法 --- json_encode(); 2. 将字符串转换为对象的方式 --- json_decode(); 3. 如何更好的理解接口这个概念 接口说白了就是后台返回特定格式数据，而不是一个完整的页面 就是从后台到前台返回一些数据 第六节 php基础语法-11-请求流程分析第七节 php基础语法-12-前端与后端分工第八节 隐藏帧iframe方式实现页面局部更新1. 页面刷新了，刷新的虽然只是iframe子页面，这种做法是实现了页面的局部更新，但是没有异步来实现， 2. open()方法 xhr.open(&quot;get&quot;,&quot;test.txt&quot;,true); 调用open方法并不会真正发送请求，而只是启动一个请求以备发送。 它接受三个参数：要发送的请求的类型、请求的URL、表示是否异步的布尔值。 3. send()方法 如果要发送请求，用send()方法。 要发送特定的请求，需要调用send()方法。 它接受一个参数，即要作为请求主体发送的数据。 如果不需要通过请求主体发送数据，则必须传入null，不能留空。 get请求是只有头部，没有主体的；而post请求有请求主体。 4. xhr对象有一个重要的属性，就是readyState属性，表示“就绪状态”； 就是 --- xhr.readyState readyState取值只有5种值：0、1、2、3、4 0 (uninitialized) 未初始化 1 (loading) XMLHttpRequest对象正在加载 2 (loaded) XMLHttpRequest对象加载完毕 3 (interactive) 正在传输数据 4 (complete) 全部完成 5. 只要readyState属性值发生了变化，就会触发一个事件onreadystatechange事件。 此时，可以用 xhr.onreadystatechange = function(){} 来捕获readyState改变之后做的事情。 6. Ajax一旦用send方法发出HTTP请求之后， 当readyState为4的时候，就会有一个属性产生 --- xhr.status 表示的是请求的文件的状态码 1** ---- 消息 2** ---- 代码请求成功 3** ---- 重定向 4** ---- 请求错误 5** ---- 服务器错误 6** ---- 其它 7、responseText 获得字符串形式的响应数据。 如果来自服务器的响应并非 XML，请使用 responseText 属性。 8、responseXML 获得 XML 形式的响应数据。 9、XMLHttpRequest 对象用于和服务器交换数据。 10、setRequestHeader --- 向请求添加 HTTP 头 xhr.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;); 第九节 原生Ajax实现页面局部更新什么是Ajax 在不刷新页面的情况下，浏览器悄悄地、异步地向服务器发出HTTP请求。 服务器收到请求后，传回新的格式化数据回来（通常是JSON）。 浏览器解析JSON，通过DOM将新数据呈递显示，页面仅局部刷新 第十节 原生Ajax详解-xhr对象创建1. 标准下 --- xhr = new XMLHttpRequest(); 2. IE6 --- xhr = new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;); 第十一节 原生Ajax详解-请求参数分析1. open()方法 参数一： 请求方式（get获取数据，post提交数据）； 参数二： 请求的地址 参数三： 同步或者异步标识位，默认是true标识true，false表示 注意：如果是get请求，那么请求参数必须在url中传递 encodeURI()用来对中文参数进行编码，防止乱码。 2. send()方法 get请求这里需要添加null参数 3. post请求参数通过send传递，不需要通过encodeURI()转码 但是必须需要设置请求头参数 Part 3第一节 原生Ajax详解-xml数据格式什么是XML 1、XML指可扩展的标记语言 2、主要用来输出和存储数据 --- 注意：设置宗旨是【传输数据】，而非显示数据 3、XML标签没有预定义，需要自行定义标签 --- 就是说XML具有自我描述性 XML 数据格式的缺点 1、元数据占用的数据量比较大，不利于大量数据的网络传输 2、解析不太方便 XML和HTML的区别 1、XML是用来传输和存储数据的，而HTML被设计是用来显示数据的 2、XML旨在传输数据，HTML旨在显示信息 XML的树结构 1、XML 文档形成了的也是一种“树结构”， 2、**【XML文档必须包含根元素】**。该元素是所有其他元素的父元素。树结构从根部开始，扩展到最低端 XML的语法 1、所有XML元素都必须都闭合标签 2、XML标签对大小写敏感，因此必须使用相同的大小写来编写打开标签和关闭标签 3、XML必须正确地嵌套 4、XML 文档必须有根元素 5、XML 的属性值须加引号 6、XML 中的注释 --- \\&lt;!-- … --&gt; 7、在 XML 中，空格会被保留 8、一些特殊符号需要用实体引用 第二节 原生Ajax详解-json数据格式 什么是JSON JavaScript 对象表示法 是存储和交换文本信息的语法 轻量级的文本数据交换格式 JSON数据和普通的JS兑现的区别 json 对象没有变量 json 形式的数据结尾没有分号 json 数据中的键必须用双引号包括 JSON和XML对比 JSON 比 XML 更小、更快，更易解析 第三节 原生Ajax详解-json数据解析 把JSON文本转换为JavaScript对象 JSON 最常见的用法之一，是从 web 服务器上读取 JSON 数据（作为文件或作为 HttpRequest），将 JSON 数据转换为 JavaScript 对象，然后在网页中使用该数据。 为什么要转换 在数据传输过程中，json是以文本，即字符串的形式传递的，而JS操作的是JSON对象，所以，JSON对象和JSON字符串之间的相互转换是关键。 转换的方法 JSON.parse() — 把json形式的字符串转成对象 JSON.stringify() — 把对象转成字符串 eval() — 把字符串解析成JS代码并执行 第四节 原生Ajax详解-php开发json形式数据接口 json_encode() — 把数组转换成JSON形式的字符串 第五节 原生Ajax详解-初步理解异步效果同步 等待一个请求完成，后续进程被阻塞，只有等请求返回后，再能执行后续的语句 异步 不等待请求完成，立即执行后续语句，请求返回后，在执行回调函数里面的语句 多线程， 就是指计算机CPU有一定的物理结构，能够在物理上，同时计算两个东西。一边算加法，一遍算乘法。程序是并发的。 单线程，就是计算机每时每刻，只有一个计算任务在执行。程序不是并发的。 拓展 单线程也能异步。就是你的程序只用一个线程，也就是说计算机同一时刻只能计算一个任务。那为什么还能异步呢？？原因是，异步的时候，CPU把请求已经交给了磁盘这个物理硬件，而CPU还在以单线程运行。比如世界著名 Node.js语言，就是非常著名的单线程、异步的语言。 多线程也能同步。多线程，就是CPU能够同时计算多个命令，但是程序就是选择傻等，你管得着么？比如PHP是世界上最最注明的多线程语言，但是里面提供的读取文件方法，全是同步的。 第六节 原生Ajax详解-同步与异步底层原理分析 浏览器单线程，浏览器事件队列 事件队列中的任务执行的条件 定时函数（延时时间已经达到） 事件函数（特定事件被触发） ajax的回调函数（服务器有数据响应） 更多原理详细看： http://www.cnblogs.com/Mainz/p/3552717.html http://www.ruanyifeng.com/blog/2014/10/event-loop.html 第七节 原生Ajax详解-Ajax初步封装- 抽取函数 --- 学会抽取函数 - 实际开发中，重复利用的代码块也要封装成一个函数 第八节 jQuery框架-Ajax相关API基本使用jQuery ajax 方法，在使用时参考手册即可。 常用的jQuery ajax参数： $.ajax({ type : &quot;&quot;, url : &quot;&quot;, data : &quot;&quot;, dataType : &quot;&quot;, success : function(data){ } }); Part 4同源策略什么是跨域 同源策略是浏览器的一种安全策略，所谓同源指的是请求URL地址中的协议、域名和端口号都相同，只要其中之一不相同就是跨域。 同源策略主要是为了保证浏览器的安全性 在同源策略下，浏览器不允许Ajax跨域获取服务器数据 说简单点：跨域是指从一个域名的网页去请求另一个域名的资源。只要协议、域名、端口有任何一个的不同，就被当作是跨域。 跨域解决方案 1、jsonp， 2、document.domain + iframe 3、location.hash + iframe 4、window.name + iframe 5、window.postMessage 6、flash 等第三方插件 99%的公司都在使用jsonp。 注：前端解决跨域问题的8种方案（有兴趣的同学课下研究） http://www.cnblogs.com/JChen666/p/3399951.html JSONP的原理（1）静态script标签的src属性进行跨域请求 如果使用src这种方法进行跨域的话，一定要把这段获取数据的代码上面线先行加载，使用数据的方法放在后加载 这种方法的缺点就是非常的不灵活， 这种方法已经极少使用，了解即可 利用script标签的跨域能力，这就是jsonp的基础。 利用js构造一个script标签，把json的url赋给script的scr属性，把这个script插入到dom里，让浏览器去获取。 JSONP的原理（2）动态创建script标签，通过标签的src属性发送请求 动态创建script标签发出去的请求是异步请求 服务器响应的内容【函数调用】 JSONP的原理（3）1、jsonp的本质：动态创建script标签，然后通过它src属性发送跨域请求，然后服务器响应的数据格式为【函数调用（foo实参）】 所以在发送请求之前必须显示先声明一个函数，并且函数的名字与参数中传递的名字要一致，这里声明的函数是由服务器响应的内容， （实际就是一段js代码-函数调用）来调用 2、注意：ajax和jsonp其实本质上是不同的东西。 ajax的核心是通过XmlHttpRequest获取非本页内容， 而jsonp的核心则是动态添加&lt;script&gt;标签来调用服务器提供的js脚本。 3、贺师俊 --- JSONP 的工作原理是什么 就是利用&lt;script&gt;标签没有跨域限制的“漏洞”（历史遗迹啊）来达到与第三方通讯的目的。 当需要通讯时，本站脚本创建一个&lt;script&gt;元素，地址指向第三方的API网址， 形如： &lt;script src=&quot;http://www.example.net/api?param1=1&amp;param2=2&quot;&gt;&lt;/script&gt; 并提供一个回调函数来接收数据（函数名可约定，或通过地址参数传递）。 第三方产生的响应为json数据的包装（故称之为jsonp，即json padding），形如： callback({&quot;name&quot;:&quot;hax&quot;,&quot;gender&quot;:&quot;Male&quot;}) 这样浏览器会调用callback函数，并传递解析后json对象作为参数。本站脚本可在callback函数里处理所传入的数据。 4、定义函数，一定要写在调用JSONP之前。也就是，调用任何外部js，都没有函数声明头的提升。","tags":[]},{"title":"","date":"2017-03-13T11:48:49.972Z","path":"2017/03/13/angular/","text":"AngularAngular 与 jQuery jQuery: 库 提供了一些已有的方法，我们主动调用它。 $(‘.test’).val() Angular: 框架 框架提供了一种结构或者模式 我们按照它提供这种结构或者模式去书写代码 框架会帮助我们去剩下的事情 Angular简介 一款非常优秀的前端高级 JS 框架 最早由 Misko Hevery 等人创建 2009 年被 Google 公式收购，用于其多款产品 目前有一个全职的开发团队继续开发和维护这个库 有了这一类框架就可以轻松构建 SPA 应用程序 其核心就是通过指令扩展了 HTML，通过表达式绑定数据到 HTML。 什么是 SPA single page application 单页应用程序 指令 在angular中以ng-开头的html标签属性，称之为指令 ng-app: 选择angular去管理哪一部分的html代码, 管理的是ng-app所在 元素的子元素及其本身 ng-click: 也是用来注册点击事件 ng-model: 可以指定一个属性值，这个属性就表示当前文本框的value值 ng-init: 可以对数据进行初始化操作，给一个默认值。 模块 创建模块:var app = angular.module(&#39;模块名&#39;,[]) 注意 如果不依赖其他模块，也需要提供一个空的数组 需要在ng-app指令的属性值上写我们的模块名(房子) 控制器 创建控制器:app.controller(&#39;控制器的名字&#39;,function($scope){}) 如果要改变页面的值，就直接改变$scope.testName值就可以 注意 要显示数据模型的值,就要在它所在标签或者父标签上加上ng-controller指令ng-controller的值就是我们想要显示的数据模型所在控制器的名字:ng-controller=”window” 双向数据绑定 数据模型($scope.属性)的改变，会影响内容的显示(文本框的值) 我们改变了文本框的值，对应的数据模型发生了改变. 这种相互影响的关系就称之为双向数据绑定. MVC 思想 M : Model: 存储，获取数据 V : View 视图，把数据呈现给用户 C : Controller 做一些控制和调度的操作 Angular vs jQuery 提高了dom操作的效率 不推崇dom操作 angular.element, 使用方式和jquery非常像,jqLite对象 可以把angular.element当作jQuery的$来用， 注意angular.element 要求传入的参数是一个原生的dom对象，而不是选择器 回顾并总结Angular开发流程 1.在html中引入angular.js文件 2.在html中加上ng-app指令，告诉angular要管理页面哪一部分代码 3.在js中创建模块angular.module(&#39;myApp&#39;,[]),给ng-app指令一个值， 这个值就是这个模块的模块名:myApp 4.在js中创建控制器xxx.controller(&#39;控制器名字&#39;,function($scope){}),我们需要在页面上加上ng-controller指令，指令的值为控制器的名字ng-controller=&quot;控制器名字&quot; 5.建模:根据页面结构，抽象出具体的js对象. 6.通过$scope做一些初始化操作$scope.username=&quot;小明&quot; 7.通过ng-model , ng-click , {{}} 把$scope的属性在页面展示出来 8.在js写一些具体的逻辑 MVC MVC只是一种思想，只是约定了我们代码应该如何去组织 让我们代码的每一部分都有一个明确的职责 用利于后期的维护性(并不是提高了代码的执行性能,有可能10行代码放到10个方法里, 10方法再放到10文件去.) $scope 视图和控制器之间的数据桥梁 用于在视图和控制器之间传递数据 用来暴露数据模型（数据，行为） ViewModel $scope 实际上就是MVVM中所谓的VM（视图模型） 正是因为$scope在Angular中大量使用甚至盖过了C（控制器）的概念，所以很多人（包括我）把Angular称之为MVVM框架 这一点倒是无所谓，具体看怎么用罢了 Angular 模块 angular.module(‘模块名’,[]) Angular中模块的划分方式 1.按照项目的功能去划分模块 2.按照项目中文件的类型去划分模块 Angular 控制器传统的方式创建控制器123456789// 创建控制器(1.2.x版本)// angular会把全局的函数当作控制器function demoController($scope)&#123; $scope.name = '小明'&#125;function xxx($scope)&#123; $scope.age = 18&#125; 面向对象的方式创建控制器12345&lt;!-- 这里的obj 代表控制器中回调函数new 出的对象 --&gt;&lt;div ng-controller=\"demoController as obj\"&gt; &lt;p&gt;&#123;&#123;myname&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;obj.name&#125;&#125;&lt;/p&gt;&lt;/div&gt; 123456789// 1.创建模块var app = angular.module('myApp', [])// 2.创建控制器// angular会把这二个参数当作构造函数使用app.controller('demoController', function($scope)&#123; $scope.myname='小红' this.name = '小明'&#125;) 安全的方式创建控制器 就是为了避免压缩后代码无法运行 1234567// 把第二个参数改为一个数组,在数组把我们需要的参数的名字写上// 回调函数就写在数组的最后一个元素上// *注意*：数据中传入的元素的顺序,要和function的中顺序一一对应app.controller('demoController',['$scope','$log',function($scope,$log)&#123; $scope.msg = 'hello World!' $log.log('哈哈哈哈！')&#125;]) 指令ng-bind 可以解决表达式闪烁问题: &lt;p ng-bind=&quot;msg&quot;&gt; &lt;/p&gt; 浏览器不会把标签的属性显示出来! 效果：angular会把ng-bind对应的数据显示到所在标签中间 ng-cloak 可以解决表达闪烁问题: &lt;div class=&quot;ng-cloak&quot;&gt;&lt;p&gt;{{msg}}&lt;/p&gt;&lt;/div&gt; 先隐藏后显示 angular在解析表达式之后会把页面上的ng-cloak样式移除, 这样ng-cloak对应的样式就不生效了,我们就先给ng-cloak设置display:none; ng-repeat 能够把一组数据直接渲染到页面上，不需要我们拼接字符串 我们希望重复的是哪个元素就把ng-repeat指令加在哪个元素上，不一定是li上 ng-repeat=”item in users” , item对应是遍历users时的第一条数据，users是我们 要遍历的数据(是一个数组) 1234&lt;!-- ng-repeat 遍历生成数据，类似for in 循环的语法 --&gt; &lt;li ng-repeat=\"item in users\" &gt; &#123;&#123;item.name&#125;&#125; , &#123;&#123;item.age&#125;&#125; &lt;/li&gt; ng-repeat补充 ng-repeat 在遍历时会提供以下值: $odd : 为true时，表明当前数据是否是第[奇]数条 $even: 为true时，表明当前数据是否是第[偶]数条 $first: 为true时，表明当前数据是否是第1条 $last: 为true时，表明当前数据是否是最后一条 $middle: 为true时，表明当前数据是否是中间的数据 12345&lt;!-- $odd, ng-repeat在每次遍历时都提供这样的值，为true表明当前数据是否第奇数条,从索引为0开始判断的 --&gt;&lt;!-- $even, ng-repeat在每次遍历时都提供这样的值，为true表明当前数据是否第偶数条,从索引为0开始判断的 --&gt; &lt;li class=\"&#123;&#123; $odd ?'red':'green'&#125;&#125;\" ng-repeat=\"item in data\"&gt; &#123;&#123;item.name&#125;&#125;,&#123;&#123;item.age&#125;&#125; &lt;/li&gt; ng-class ng-class 可以帮助我们控制元素的class样式， ng-class 可以独立在其他元素上使用，并非一定要和ng-repeat结合 123456&lt;!-- ng-class,动态的添加class样式, 以对象的形式书写，angular会把属性值为true的属性名当作样式添加到class class=\"green\" --&gt;&lt;li ng-class=\"&#123;red:item.age&gt;=20, green:item.age&gt;=10&amp;&amp;item.age&lt;20,blue:item.age&lt;10&#125;\" ng-repeat=\"item in data\"&gt; &#123;&#123;item.name&#125;&#125;,&#123;&#123;item.age&#125;&#125;&lt;/li&gt; ng-show/ng-hide 控制元素的显示与否,ng-show与ng-hide作用是相反的(只是设置display:none来隐藏元素) 1234&lt;!-- ng-show,控制元素的显示或隐藏,值为true时显示，为false隐藏--&gt;&lt;p ng-show=\"isShowing\"&gt;我是中国人，我爱自己的祖国!&lt;/p&gt;&lt;!-- ng-hide 值为true时，隐藏当前元素 --&gt;&lt;p ng-hide=\"true\"&gt;我是小明!&lt;/p&gt; ng-if 控制元素的显示与否:值为false时，元素会从dom移除 1234&lt;!-- ng-if，也能控制元素的显示或隐藏,为true时显示,为false时【会将当前dom元素移除】 --&gt;&lt;p ng-if=\"true\"&gt;我是中国人，我爱自己的祖国!&lt;/p&gt;&lt;h1&gt;ng-if=\"false\"&lt;/h1&gt;&lt;p ng-if=\"false\"&gt;我是中国人，我爱自己的祖国!&lt;/p&gt; ng-switch 当ng-switch-when 对应的值等于ng-switch对应值时，当前dom元素就显示 12345678&lt;div ng-switch=\"name\"&gt; &lt;div ng-switch-when=\"小明\"&gt; 我是小明，我在这里！ &lt;/div&gt; &lt;div ng-switch-when=\"小红\"&gt; 我是小红! &lt;/div&gt;&lt;/div&gt; 其他常用指令 ng-checked： 单选/复选是否选中,（单向数据绑定:界面操作不会影响数据模型的值） ng-model:双向数据绑定 ng-selected： 是否选中 ng-disabled： 是否禁用 ng-readonly： 是否只读 常用事件指令不同于以上的功能性指令，Angular还定义了一些用于和事件绑定的指令： ng-blur：失去焦点 ng-focus： 获得焦点 ng-change：内容改变 ng-copy：复制 ng-click: ng-dblclick：双击 ng-submit： form表单提单 指令的其他使用方式data-xxx,在使用angular指令时，只需要在原先的指令前加上data-前缀。如: data-ng-app,data-ng-clickx-ng-app,x-ng-click 自定义指令 自定义指令无外乎增强了HTML,提供了额外的功能。 内部指令基本能满足我们的需求。 少数情况下我们有一些特殊的需要，可以通过自定义指令的方式实现 创建自定义指令 注意: 名字要符合驼峰合法 1234567891011121314// 1.创建模块对象var app = angular.module('directiveApp', [])// 2.创建自定义指令// 第一个参数：是指令的名字,必须是驼峰命名法// 使用时把大写改成小写，在原来大写前加上-// 第二个参数：和控制器的第二个参数类似!app.directive('myBtn', [function()&#123; // 在这里直接return 一个对象就可以了 return &#123; // template属性，是封装的ui template:'&lt;div&gt;&lt;button&gt;我是按钮&lt;/button&gt;&lt;/div&gt;' &#125;&#125;]) 自定义指令中回调里返回的对象的属性 template: 需要提供一个html字符串,最终会被添加到当前页面使用了自定义指令的位置 templateUrl:需要提供一个html文件路径，angular会发请求，请求对应的文件，把文件内容作为模板插入到自定义指令中间 : 也可以提供一个script标签的id, angular会把script标签中的内容作为 模板插入到自定义指令中间,*注意* 要改变script标签的type=&quot;text/ng-template&quot; restrict: 也是需要提供一个字符串，限制自定义指令的使用形式 A : Attribute 表示只能以属性的形式使用 C : Class 表示只能以类样式名的形式使用 E : Element 表示只能以自定义标签的形式使用 ACE : 如果希望多种方 式合适，就把对应值组合在一起。 replace：需要提供一个布尔值，为true时，模板会被用来替换自定义指令所在标签， * 否则是插入到自定义指令中间 transclude: 需要一个布尔值, 为true时会将自定义标签中的内容插入到模板中， * 拥有ng-transclude 指令的标签中间 scope：需要一个对象: 可以用来获取自定义指令的属性值, 给当前对象添加一个属性(如:tmp),属性值以@开头，后面跟上自定义指令的属性名然后就可以在模板中使用 来得到对应的属性值 scope: { tmp:&#39;@mystyle&#39;} {{tmp}} scope: { mystyle:&#39;@&#39;} link: 需要一个function 这是function在angular解析到相应指令时就会执行一次, scope ：类似于$scope,只不过scope的属性只能在模板中使用 element : 自定义指令所在标签对应的对象(jqLite) attributes : 包含了自定义指令所在标签的必有属性 todomvc案例todomvc功能分析 任务的展示 添加任务 删除任务 修改任务内容 切换任务完成与否的状态 批量切换任务完成与否的状态 显示未完成的任务数 清除所有已完成任务 注意： 在循环删除数组长度，会导致循环条件改变，也会导致元素原来的索引改变 切换显示不同状态的任务 过滤器(filter) 格式化数据 过滤数据(filter) 1234567&lt;ul&gt; &lt;!-- 如果指定一个布尔值，或者字符串就是全文匹配 --&gt; &lt;!-- 会到对应的todos中寻找，如果当前元素有completed属性且值 为true就会被显示出来。（只会到completed属性中寻找） --&gt; &lt;li ng-repeat=\"item in todos | filter : &#123;completed:true&#125; \"&gt; &#123;&#123;item.name&#125;&#125;,&#123;&#123;item.completed&#125;&#125; &lt;/li&gt;&lt;/ul&gt; 1234567&lt;h1&gt;currency&lt;/h1&gt;&lt;!-- 在数据模型后加上| 再加上过滤器的名字 也可以在过滤器名字后指定参数，参数是写在冒号后面的--&gt;&lt;p&gt;&#123;&#123;money | currency : '￥'&#125;&#125;&lt;/p&gt;&lt;h1&gt;date&lt;/h1&gt;&lt;p&gt;&#123;&#123;myDate | date : 'yyyy年MM月dd日 HH:mm:ss'&#125;&#125;&lt;/p&gt; limitTo 123 &lt;h1&gt;limitTo&lt;/h1&gt;&lt;!-- 第一个参数，表明显示多少个字，第二个参数表示，从第几个字开始显示(索引从0开始) --&gt;&lt;p&gt;&#123;&#123;msg | limitTo : 5 : 2&#125;&#125;...&lt;/p&gt; orderBy 及 json 123456&lt;h1&gt;json&lt;/h1&gt; &lt;!-- 格式化显示json数据，参数指定缩近的长度 --&gt; &lt;pre&gt;&#123;&#123;myJson | json : 8&#125;&#125;&lt;/pre&gt; &lt;h1&gt;orderBy&lt;/h1&gt; &lt;!-- 对数据进行排序，参数，给+号就按正序排，- 就按倒序排 --&gt; &lt;span ng-repeat=\"item in arr | orderBy:'-'\"&gt;&#123;&#123;item &#125;&#125;，&lt;/span&gt; 在js中使用过滤器 1234567&lt;!-- $filter 需要在控制器的回调中传入 --&gt;// 可以调用不同的过滤器得到相应的结果 // 参数是一个过滤器的名字 // 返回值是一个方法 // : 第一个参数是需要处理的数据 // : 后面的参数是当前过滤器本身需要的参数 $scope.result = $filter('currency')($scope.money,'￥') todomvc使用filter过滤器来切换不同状态任务的显示 arr=[{a:3,b:4},{a:5}] 数据模型 | filter : {a:3} $watch 监视数据模型的变化123456789101112$scope.name = '小明' $scope.age = 18 // $watch可以用来监视数据模型的变化 // 第一个参数: 数据模型对应的名字(字符串形式) // 第二个参数: 相应的数据模型变化就会调用 这个函数 // 默认会直接执行一次回调函数 $scope.$watch('name',function(now,old)&#123; // 第一个参数是变化后的值 // 第二个参数是变化前的值 // console.log(now,old) &#125;) 也可以监视方法的返回值 12345678$scope.getAge = function()&#123; return $scope.age &#125; // 也能够监视$scope.属性中的方法的返回值 $scope.$watch('getAge()',function(now,old)&#123; console.log(now,old) &#125;) 服务 创建服务 12345678910 // 1.创建服务模块var app = angular.module('service',[])// 2.创建服务// 第一个参数：服务的名字// 第二个参数里的function: // angular会把这个function当作构建函数，angular会帮助我们new这个构建函数，然后得到一个对象。A,Bapp.service('MyService', [function()&#123; this.name = '小明'&#125;]) 使用服务 123456789 // 1.创建模块 var app = angular.module('todosApp', ['service']) // 2.创建控制器 app.controller('todosController', [ 'MyService' , function(MyService)&#123; // 这个MyService就是，对应的'MyService'时的回调函数new出的对象 console.log(MyService)&#125;]) 路由 根据url中不同的锚点值，在页面显示不同的内容！ 路由使用123456789101112131415161718192021// 1.创建模块var app = angular.module('myApp', ['ngRoute'])// 2.配置路由规则(约定什么样的锚点值，对应什么样的内容)// 第一个参数与controller第二个参数类似app.config(['$routeProvider',function($routeProvider)&#123; // 第一个参数：对应的url中锚点值 // 当angular检测到url中锚点变为/ali里，就会把template对应的内容插入到页面拥有ng-view指令的标签中 $routeProvider.when('/ali',&#123; template:'&lt;div&gt;阿里在二楼!&lt;/div&gt;', // 指定一个控制器的名字, // 当前url中锚点值为/ali时就会执行控制器中的回调函数 // 我们可以直接在template/templateUrl对应的模板中使用该控制器中对应的$scope属性值 controller:'demoController' //templateUrl &#125;) .when('/baidu',&#123; template:'&lt;div&gt;百度在1楼&lt;/div&gt;' &#125;)&#125;]) 路由参数 在原有规则中可以加冒号:, 表示:号后的内容是可以变的(但是必须要有) 如果加上问号，就能够匹配到了 在控制器中可以通过$routeParams得到myname对应的值 1$routeProvider.when('/company/:myname？') otherwise 当不匹配when方法对应的规则时，就会匹配otherwise对应的规则 webapi I/O // url api console.log(‘小明’) //小明 I/O docuemnt.getGetElementById(‘’) ng-src 指令: 用来取代src$http 发请求 123456http.get('./in_theaters/data.json') .then(function(res)&#123; // 成功的回调函数 // console.log(res.data) $scope.data = res.data &#125;)","tags":[]},{"title":"","date":"2017-03-07T12:41:20.904Z","path":"2017/03/07/git/","text":"Git什么是Git? Git是一款源代码管理工具(版本控制工具) 我们写的代码需要使用Git进行管理。1.0是稳定2.0加了新功能 源代码有必要管理起吗？ 有必要，因为人工的去处理不同的版本，做相应备份会很麻烦。 svn,vss,vcs,tfs…..-Git是linux之父当年为了维护linux—linus之前也是手动维护合并把文件发给Linus BitKeeper(收费) 有人想破解(不给提供免费使用) linus自己写了一个版本管理的工具（Git） 分布式版本管理工具，集中式 git属于分布式 svn集中式 git安装git初始化一个仓库 其实就是创建了一个.git隐藏目录 命令:git init; 想在哪个目录创建.git目录，就是哪个目录打开工具然后写命令. 一般是在项目的根目录执行这个命令. 自报家门 配置用户名 : git config user.name &quot;testName&quot; 配置邮箱 : git config user.email &quot;test@sina.com&quot; 查看配置信息: git config --list 把代码提交到仓库中 1.先把代码添加到暂存区(就相当于放到仓库门口) 命令:git add 文件路径 示例:git add ./reademe.md 可以使用git add .这个命令，批量把当前目录下所有修改过的文件添加到暂存区。 2.把暂存区的文件提交仓库里 命令: git commit -m &quot;注释&quot; 示例: git commit -m &quot;我们添加了一个新的功能&quot; -m 表示指定一个字符串，作为提交的说明(相当于注释); 合并add 与commit 命令 git commit -a -m &quot;这是使用合并添加与提交的操作&quot;;或者git commit -am ;或者git commit –all -m 这里-a参数表明把所有修改后的文件一起添加到暂存区.(只是对修改后的文件有效，对于新添加的文件没有作用) 查看工作区状态 命令:git status 添加忽略文件 在项目中有一些文件是不需要提交的,我们需要把它忽略掉 需要在.git文件夹所在目录新建一个名为.gitignore的文件然后在这个文件中写上需要被忽略的文件的路径。示例: /css/a.css: /css/*.css : /a.html 比对文件差异 命令: git diff 用来比较工作区内容与最近一次提交的内容的区别 如果暂存区没有文件，就会将工作与代码与最近一次提交对比 命令：git diff --cached 比较暂存区的文件和仓库中文件的区别 对比之前某两次提交的文件的差异 命令:git diff [版本号1] [版本号2] [想比较的文件路径] 查看日志 命令:git log,可以查看每一次提交的日志 命令:git log --oneline 表示使用简洁的形式输出提交日志 版本回退 命令:git reset --hard Head~1 这是将代码回退到上上一次提交时的状态 命令:git reset --hard Head~2 回退到上上上次 命令:git reset --hard Head~0 回退到上次提交时的状态,~0可以省略 命令:git reset --hard 版本号 通过每次提交时生成的版本号来回退版本 通过git reflog命令可以查看之前所有版本切换的操作记录，可以通过这个命令得到的版本号回退到指定的版本。 创建分支 命令:git branch [分支名] 创建一个新分支 命令:git branch 查看当前所有的分支 切换分支 命令:git checkout [分支名] 切换分支后可以在切换后的分支中进行正常的操作 合并分支 命令:git merge [分支名] git会将指定的分支合并到当前分支. 删除分支 命令:git branch -d [分支名] 删除指定分支，-d参数表示要执行删除操作 git提交中的冲突 如果git不能自动合并分支，就会有冲突，我们需要手动解决冲突，然后再次提交 githubgithub与git git 版本管理工具 github 就是一个网站，只是这个网站提供git服务器的功能 上传代码到git服务器(push) 命令:git push [远程服务器地址] [远程服务器的分支] 示例:git push https://github.com/huoqishi/test002.git master 上传时可以使用一些简化的命令 将远程服务器地址写成变量的形式 git remote add [变量名] [远程服务器地址] 示例:git remote add origin https://github.com/huoqishi/test002.git 这样之后就可以直接使用origin来代替git push 后面写的地址了git push origin master 还可以尽一步简化 在push时加上-u参数，就会默认建立本地当前分支与远程指定分支的关联,下一次push时就不需要输入分支名了git push origin;","tags":[]},{"title":"","date":"2017-03-07T12:41:20.904Z","path":"2017/03/07/gulp/","text":"gulpnpm node package manager 管理项目的依赖包 可以用来下载我们需要使用的东西 安装后可以通过npm -v 查看版本 npm 使用 1.初始化操作 npm init 会生成一个package.json文件 2.下载所需要的包 npm install jquery 下载jquery 会去 registry.npmjs.org 这个地址下载jquery 会生成一个node_modules目录，下载的内容就放在这个目录 3.下载包时，可以加上 --save 参数 npm install jquery --save, 下载之后会在package.json中添加当前下载的包的版本信息。 gulp官网中文网 前端自动化构建工具 js: function(){//},代码压缩,混淆 : var name = 123,var x = 123 css, 合并: 1个js 1kb ,有10个js. 5个核心方法 gulp.task(‘任务名’,function(){}) // 创建任务。 gulp.src(‘./*.css’) 指定想要处理的文件 gulp.dest() // 指定最终处理后的文件的存放路径 gulp.watch() // 自动的监视文件的变化，然后执行相应任务。 gulp.run(‘任务名’)，直接执行相应的任务。 安装gulp 通过npm安装:npm install gulp-cli -g gulp使用 1.在当前项目中也要安装gulp: npm install gulp --save 2.还需要在当前项目中新建一个文件: gulpfile.js 12345678 var gulp = require('gulp'); // 创建任务 // 第一个参数: 任务名 // 第二个参数: 回调函数,当我们执行任务时就会执行这个函数 gulp.task('test', function()&#123; console.log(123)&#125;) 3.执行任务: gulp 任务名 示例: gulp test 对js进行压缩 npm install gulp-uglify --save 对js进行合并操作 npm install gulp-concat --save 1234567891011 gulp.task('script', function()&#123; // 1.要匹配到要处理的文件 // 指定指定的文件:参数是匹配的规则 // 参数也可以是数组，数组中的元素就是匹配的规则 gulp.src(['./app.js','./sign.js']) // concat 的参数是合并之后的文件名字 .pipe(concat('index.js')) .pipe(uglify()) // dest方法参数，指定输出文件的路径 .pipe(gulp.dest('./dist'))&#125;) 对css进行压缩操作 npm install gulp-cssnano --save 123456789101112 // 新建一个任务，对css进行处理gulp.task('style', function()&#123; // 对项目中的2个css文件进行合并，压缩操作 // 1.匹配到要处理的文件 gulp.src(['./*.css']) // 2.合并文件 .pipe(concat('index.css')) // 3.压缩操作 .pipe(cssnano()) // 4.输出到指定目录 .pipe(gulp.dest('./dist')) &#125;) 对html进行压缩 npm install gulp-htmlmin --save https://github.com/kangax/html-minifier 123456789 // 新建一个任务，对html进行压缩gulp.task('html', function()&#123; // 1.匹配到要处理的文件 gulp.src(['./index.html']) // 2.压缩操作 .pipe(htmlmin(&#123;collapseWhitespace:true&#125;)) // 3.指定输出目录 .pipe(gulp.dest('./dist'))&#125;) gulp.watch 监视文件的变化，然后执行相应的任务 gulp.run, 直接执行指定的任务 123456789 // gulp.watch 监视文件变化，执行相应任务 gulp.task('mywatch', function()&#123; // 执行指定的任务 gulp.run('script') // 1.监视js文件的变化，然后执行script任务 // 第一个参数：要监视的文件的规则 // 第二个参数：是要执行的任务 gulp.watch(['./app.js','sign.js'],['script'])&#125;)","tags":[]}]